import { renderHook, act } from '@testing-library/react';
import { Track } from '../../types';
import { usePlayerState } from '../usePlayerState';

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
  length: 0,
  key: jest.fn(),
};

// Mock Howler
const mockHowl = {
  play: jest.fn(),
  pause: jest.fn(),
  stop: jest.fn(),
  volume: jest.fn(),
  seek: jest.fn(),
  on: jest.fn(),
  off: jest.fn(),
  duration: jest.fn(() => 180),
  playing: jest.fn(() => false),
};

jest.mock('howler', () => ({
  Howl: jest.fn(() => mockHowl),
  Howler: {
    volume: jest.fn(),
    mute: jest.fn(),
    stop: jest.fn(),
  },
}));

// Mock tracks
const mockTrack: Track = {
  id: '1',
  title: '테스트 트랙',
  artist: '오안나',
  duration: 180,
  file: '/music/test.mp3',
  cover: '/covers/test.jpg',
  description: '테스트용 트랙입니다.',
};

const secondTrack: Track = {
  id: '2',
  title: '두 번째 트랙',
  artist: '오안나',
  duration: 200,
  file: '/music/test2.mp3',
  cover: '/covers/test2.jpg',
  description: '두 번째 테스트용 트랙입니다.',
};

const tracks = [mockTrack, secondTrack];

describe('usePlayerState Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    localStorageMock.getItem.mockReturnValue(null);
    localStorageMock.setItem.mockReturnValue(undefined);
  });

  test('초기 상태가 올바르게 설정된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    expect(result.current.isPlaying).toBe(false);
    expect(result.current.currentTrack).toBeNull();
    expect(result.current.volume).toBe(1);
    expect(result.current.isMuted).toBe(false);
  });

  test('트랙을 재생하면 상태가 올바르게 변경된다', async () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    await act(async () => {
      result.current.playTrack(mockTrack);
    });

    expect(result.current.isPlaying).toBe(true);
    expect(result.current.currentTrack).toEqual(mockTrack);
    expect(mockHowl.play).toHaveBeenCalled();
  });

  test('재생 중인 트랙을 일시정지하면 상태가 올바르게 변경된다', async () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    await act(async () => {
      result.current.playTrack(mockTrack);
    });

    await act(async () => {
      result.current.togglePlay();
    });

    expect(result.current.isPlaying).toBe(false);
    expect(mockHowl.pause).toHaveBeenCalled();
  });

  test('볼륨을 변경하면 상태가 올바르게 업데이트된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setVolume(0.5);
    });

    expect(result.current.volume).toBe(0.5);
    expect(mockHowl.volume).toHaveBeenCalledWith(0.5);
  });

  test('음소거 상태가 올바르게 토글된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.toggleMute();
    });

    expect(result.current.isMuted).toBe(true);

    act(() => {
      result.current.toggleMute();
    });

    expect(result.current.isMuted).toBe(false);
  });

  test('다른 트랙을 재생하면 이전 트랙이 자동으로 정지된다', async () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    await act(async () => {
      result.current.playTrack(mockTrack);
    });

    await act(async () => {
      result.current.playTrack(secondTrack);
    });

    expect(result.current.currentTrack).toEqual(secondTrack);
    expect(mockHowl.stop).toHaveBeenCalled();
  });

  test('진행률이 올바르게 업데이트된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setProgress(30);
    });

    expect(result.current.progress).toBe(30);
  });

  test('재생 시간이 올바르게 업데이트된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setCurrentTime(60);
    });

    expect(result.current.currentTime).toBe(60);
  });

  test('트랙이 끝나면 자동으로 다음 트랙으로 넘어간다', async () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    await act(async () => {
      result.current.playTrack(mockTrack);
    });

    // 트랙 종료 이벤트 시뮬레이션
    act(() => {
      result.current.handleTrackEnd();
    });

    expect(result.current.isPlaying).toBe(false);
  });

  test('로컬 스토리지에 설정이 저장된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setVolume(0.8);
    });

    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      'player-volume',
      '0.8'
    );
  });

  test('로컬 스토리지에서 설정을 불러온다', () => {
    localStorageMock.getItem.mockReturnValue('0.8');
    const { result } = renderHook(() => usePlayerState(tracks));

    expect(result.current.volume).toBe(0.8);
    expect(localStorageMock.getItem).toHaveBeenCalledWith('player-volume');
  });

  test('재생 목록이 올바르게 관리된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    expect(result.current.playlist).toEqual(tracks);
  });

  test('재생 모드가 올바르게 변경된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setRepeatMode('repeat');
    });

    expect(result.current.repeatMode).toBe('repeat');
  });

  test('에러 상태가 올바르게 처리된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setError('오디오 로딩 실패');
    });

    expect(result.current.error).toBe('오디오 로딩 실패');
  });

  test('로딩 상태가 올바르게 관리된다', () => {
    const { result } = renderHook(() => usePlayerState(tracks));

    act(() => {
      result.current.setLoading(true);
    });

    expect(result.current.isLoading).toBe(true);

    act(() => {
      result.current.setLoading(false);
    });

    expect(result.current.isLoading).toBe(false);
  });
});