# 🎧 13번카드 - 상세 뷰페이지 개발 가이드

> **"Shine Bright" - 오안나 음악 자료집의 완전한 구현 가이드**  
> 상세 뷰페이지 개발에 필요한 모든 기술적, 디자인적, 콘텐츠적 요소를 종합 정리

---

## 📋 목차
1. [개발 개요](#개발-개요)
2. [기술 스택](#기술-스택)
3. [화면 구조](#화면-구조)
4. [컴포넌트 설계](#컴포넌트-설계)
5. [데이터 구조](#데이터-구조)
6. [상태 관리](#상태-관리)
7. [UI/UX 가이드](#uiux-가이드)
8. [성능 최적화](#성능-최적화)
9. [접근성](#접근성)
10. [테스트 전략](#테스트-전략)

---

## 🎯 개발 개요

### 프로젝트 정보
- **프로젝트명**: Moonwave 오안나 음악 플레이어
- **도메인**: https://oh.moonwave.kr
- **기술 스택**: React + Vite + Tailwind CSS + Catalyst UI
- **배포**: GitHub Pages (GitHub Actions 자동 배포)
- **서비스 타입**: 정적 SPA + PWA

### 핵심 컨셉
> "평범함에서 특별함으로" - 재능보다 노력으로, 한계를 넘어 자신만의 빛을 찾아가는 여정을 13개의 트랙으로 표현

### 상세 뷰페이지 목적
- **Shine Bright** 곡의 완전한 음악적 경험 제공
- 가사, 해석, 싱크 가사를 통한 다층적 이해
- 오안나의 철학과 스토리텔링 구현
- 모바일 최적화된 PWA 경험

---

## 🛠️ 기술 스택

### 프론트엔드
- **React 18**: 함수형 컴포넌트 + Hooks
- **Vite**: 빠른 개발 환경 및 빌드 도구
- **TypeScript**: 타입 안정성 (선택사항)

### UI/스타일링
- **Tailwind CSS**: 유틸리티 퍼스트 CSS 프레임워크
- **Catalyst UI**: 모던 React 컴포넌트 라이브러리
- **Glassmorphism**: 글래스 효과 디자인

### 오디오 처리
- **HTML5 Audio API**: 기본 오디오 재생
- **useRef + useState**: 오디오 상태 관리
- **Web Audio API**: 고급 오디오 처리 (선택사항)

### 배포/인프라
- **GitHub Pages**: 정적 호스팅
- **GitHub Actions**: 자동 배포 파이프라인
- **PWA**: 모바일 앱 경험

---

## 🏗️ 화면 구조

### 레이아웃 구조
```
┌─────────────────────────────────────────┐
│  [← 뒤로]          트랙명               │ Header
├─────────────────────────────────────────┤
│                                         │
│         [대형 커버 이미지]              │
│                                         │
│           "Shine Bright"                │
│              문유                       │
│                                         │
├─────────────────────────────────────────┤
│  [가사] [해석] [싱크]  (탭 메뉴)        │
├─────────────────────────────────────────┤
│                                         │
│  (선택된 탭 콘텐츠 표시)                │
│                                         │
│  싱크 모드:                             │
│  ♪ 현재 재생중인 가사 라인             │
│    (실시간 하이라이트)                  │
│                                         │
├─────────────────────────────────────────┤
│         (플레이어 영역 고정)             │
└─────────────────────────────────────────┘
```

### 반응형 브레이크포인트
- **모바일**: 375px ~ 768px
- **태블릿**: 768px ~ 1024px
- **데스크톱**: 1024px+

---

## 🧩 컴포넌트 설계

### 1. DetailPage (메인 컴포넌트)
```typescript
interface DetailPageProps {
  trackId: string;
}

const DetailPage: React.FC<DetailPageProps> = ({ trackId }) => {
  // 상태 관리
  const [activeTab, setActiveTab] = useState<'lyrics' | 'interpretation' | 'sync'>('lyrics');
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  
  // 데이터 로딩
  const trackData = useTrackData(trackId);
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-white">
      <Header />
      <TrackInfo track={trackData} />
      <TabNavigation activeTab={activeTab} onTabChange={setActiveTab} />
      <TabContent 
        activeTab={activeTab} 
        track={trackData}
        currentTime={currentTime}
      />
      <Player 
        track={trackData}
        currentTime={currentTime}
        setCurrentTime={setCurrentTime}
        isPlaying={isPlaying}
        setIsPlaying={setIsPlaying}
      />
    </div>
  );
};
```

### 2. Header 컴포넌트
```typescript
const Header: React.FC = () => {
  const navigate = useNavigate();
  
  return (
    <header className="sticky top-0 z-50 bg-white/80 backdrop-blur-md border-b border-gray-200">
      <div className="flex items-center justify-between px-4 py-3">
        <Button
          variant="ghost"
          prefix={<ChevronLeftIcon className="w-5 h-5" />}
          onClick={() => navigate(-1)}
        >
          뒤로
        </Button>
        <Heading level={2} className="text-lg font-semibold">
          Shine Bright
        </Heading>
        <div className="w-10" /> {/* 균형을 위한 빈 공간 */}
      </div>
    </header>
  );
};
```

### 3. TrackInfo 컴포넌트
```typescript
interface TrackInfoProps {
  track: TrackData;
}

const TrackInfo: React.FC<TrackInfoProps> = ({ track }) => {
  return (
    <section className="px-4 py-6">
      <div className="max-w-md mx-auto text-center">
        <img
          src={track.coverUrl}
          alt={`${track.title} 커버`}
          className="w-64 h-64 mx-auto rounded-xl shadow-xl object-cover"
        />
        <Heading level={1} className="mt-4 text-2xl font-bold text-gray-900">
          {track.title}
        </Heading>
        <Text className="mt-2 text-gray-600">
          {track.artist}
        </Text>
        <Text className="mt-4 text-sm text-gray-500 leading-relaxed">
          {track.description}
        </Text>
      </div>
    </section>
  );
};
```

### 4. TabNavigation 컴포넌트
```typescript
interface TabNavigationProps {
  activeTab: 'lyrics' | 'interpretation' | 'sync';
  onTabChange: (tab: 'lyrics' | 'interpretation' | 'sync') => void;
}

const TabNavigation: React.FC<TabNavigationProps> = ({ activeTab, onTabChange }) => {
  const tabs = [
    { id: 'lyrics', label: '가사' },
    { id: 'interpretation', label: '해석' },
    { id: 'sync', label: '싱크' }
  ] as const;
  
  return (
    <TabGroup selectedKey={activeTab} onSelectionChange={(key) => onTabChange(key as any)}>
      <TabList className="flex border-b border-gray-200">
        {tabs.map((tab) => (
          <Tab
            key={tab.id}
            id={tab.id}
            className="flex-1 py-3 text-center text-sm font-medium transition-colors"
          >
            {tab.label}
          </Tab>
        ))}
      </TabList>
    </TabGroup>
  );
};
```

### 5. TabContent 컴포넌트
```typescript
interface TabContentProps {
  activeTab: 'lyrics' | 'interpretation' | 'sync';
  track: TrackData;
  currentTime: number;
}

const TabContent: React.FC<TabContentProps> = ({ activeTab, track, currentTime }) => {
  return (
    <div className="flex-1 overflow-y-auto">
      <TabPanel>
        {activeTab === 'lyrics' && <LyricsContent lyrics={track.lyrics} />}
        {activeTab === 'interpretation' && <InterpretationContent interpretation={track.interpretation} />}
        {activeTab === 'sync' && <SyncContent sync={track.sync} currentTime={currentTime} />}
      </TabPanel>
    </div>
  );
};
```

### 6. SyncContent 컴포넌트 (핵심 기능)
```typescript
interface SyncContentProps {
  sync: SyncLine[];
  currentTime: number;
}

const SyncContent: React.FC<SyncContentProps> = ({ sync, currentTime }) => {
  const [currentLineIndex, setCurrentLineIndex] = useState(0);
  
  // 현재 시간에 맞는 가사 라인 찾기
  useEffect(() => {
    const currentLine = sync.findIndex((line, index) => {
      const nextLine = sync[index + 1];
      return currentTime >= line.time && (!nextLine || currentTime < nextLine.time);
    });
    
    if (currentLine !== -1 && currentLine !== currentLineIndex) {
      setCurrentLineIndex(currentLine);
    }
  }, [currentTime, sync]);
  
  return (
    <div className="px-4 py-6 space-y-4">
      {sync.map((line, index) => (
        <div
          key={index}
          className={`transition-all duration-300 ${
            index === currentLineIndex
              ? 'text-purple-600 font-semibold text-lg bg-purple-50 rounded-lg p-3'
              : 'text-gray-600'
          }`}
        >
          {line.line}
        </div>
      ))}
    </div>
  );
};
```

### 7. Player 컴포넌트
```typescript
interface PlayerProps {
  track: TrackData;
  currentTime: number;
  setCurrentTime: (time: number) => void;
  isPlaying: boolean;
  setIsPlaying: (playing: boolean) => void;
}

const Player: React.FC<PlayerProps> = ({
  track,
  currentTime,
  setCurrentTime,
  isPlaying,
  setIsPlaying
}) => {
  const audioRef = useRef<HTMLAudioElement>(null);
  
  const handlePlayPause = () => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.pause();
      } else {
        audioRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };
  
  const handleTimeUpdate = () => {
    if (audioRef.current) {
      setCurrentTime(audioRef.current.currentTime);
    }
  };
  
  const handleSeek = (value: number) => {
    if (audioRef.current) {
      audioRef.current.currentTime = value;
      setCurrentTime(value);
    }
  };
  
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 p-4">
      <audio
        ref={audioRef}
        src={track.audioUrl}
        onTimeUpdate={handleTimeUpdate}
        onEnded={() => setIsPlaying(false)}
      />
      
      <div className="max-w-md mx-auto space-y-3">
        <Slider
          value={currentTime}
          onChange={handleSeek}
          max={audioRef.current?.duration || 0}
          className="w-full"
        />
        
        <div className="flex items-center justify-between">
          <Text className="text-sm text-gray-500">
            {formatTime(currentTime)} / {formatTime(audioRef.current?.duration || 0)}
          </Text>
          
          <ButtonGroup>
            <Button
              variant="ghost"
              onClick={() => {/* 이전 곡 */}}
            >
              <ChevronLeftIcon className="w-4 h-4" />
            </Button>
            
            <Button
              color="purple"
              variant="solid"
              onClick={handlePlayPause}
            >
              {isPlaying ? <PauseIcon className="w-5 h-5" /> : <PlayIcon className="w-5 h-5" />}
            </Button>
            
            <Button
              variant="ghost"
              onClick={() => {/* 다음 곡 */}}
            >
              <ChevronRightIcon className="w-4 h-4" />
            </Button>
          </ButtonGroup>
          
          <Button
            variant="ghost"
            onClick={() => {/* 다운로드 */}}
          >
            <DownloadIcon className="w-4 h-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};
```

---

## 📊 데이터 구조

### TrackData 인터페이스
```typescript
interface TrackData {
  id: number;
  title: string;
  artist: string;
  audioUrl: string;
  coverUrl: string;
  description: string;
  lyrics: string;
  interpretation: string;
  sync: SyncLine[];
}

interface SyncLine {
  time: number; // 초 단위
  line: string;
}
```

### 샘플 데이터 (Shine Bright)
```json
{
  "id": 13,
  "title": "Shine Bright",
  "artist": "문유",
  "audioUrl": "/music/shine-bright.mp3",
  "coverUrl": "/covers/shine-bright.jpg",
  "description": "오안나가 자신의 리듬, 궤적, 침묵, 파동 위에 스스로 빛이 되어 무대를 밝혀낸 마지막 선언곡",
  "lyrics": "숨죽인 무대 위\n조명 없는 나의 길\n반복된 silence, 깨진 trace\n하지만 그게 나의 base\n\n넘어진 자리마다\n빛보다 진한 흔적\n누가 안 봐도 괜찮아\n난 그 순간을 burn했어\n\nI wasn't lit, I learned to glow\n매일의 루틴이 만든 flow\n이건 miracle이 아냐\n그냥 내가 만든 나야\n\nI shine bright, not by chance\n내 리듬은 우연이 아냐, it's a dance\nNo more fear, no disguise\n이젠 내가 무대를 밝힌다, rise\n\nSpotlight 없어도 I'm the light\n이건 조명이 아닌 fight\n움직임 위에 새긴 fight\nI'm not lit, I ignite — I shine bright",
  "interpretation": "이 곡은 외부 조명 없이도 자신의 내면에서 발산되는 빛을 상징합니다. 'I'm not lit, I ignite'라는 핵심 철학을 통해 외부 의존적 성공에서 내재적 자체발광으로의 최종 전환을 완성합니다. 조용한 반복, 실패의 흔적, 정의되지 않은 궤적들 속에서 끝내 자기 존재의 빛을 만든 사람의 완전한 이야기입니다.",
  "sync": [
    { "time": 0, "line": "숨죽인 무대 위" },
    { "time": 3, "line": "조명 없는 나의 길" },
    { "time": 6, "line": "반복된 silence, 깨진 trace" },
    { "time": 9, "line": "하지만 그게 나의 base" },
    { "time": 12, "line": "넘어진 자리마다" },
    { "time": 15, "line": "빛보다 진한 흔적" },
    { "time": 18, "line": "누가 안 봐도 괜찮아" },
    { "time": 21, "line": "난 그 순간을 burn했어" },
    { "time": 24, "line": "I wasn't lit, I learned to glow" },
    { "time": 27, "line": "매일의 루틴이 만든 flow" },
    { "time": 30, "line": "이건 miracle이 아냐" },
    { "time": 33, "line": "그냥 내가 만든 나야" },
    { "time": 36, "line": "I shine bright, not by chance" },
    { "time": 39, "line": "내 리듬은 우연이 아냐, it's a dance" },
    { "time": 42, "line": "No more fear, no disguise" },
    { "time": 45, "line": "이젠 내가 무대를 밝힌다, rise" },
    { "time": 48, "line": "Spotlight 없어도 I'm the light" },
    { "time": 51, "line": "이건 조명이 아닌 fight" },
    { "time": 54, "line": "움직임 위에 새긴 fight" },
    { "time": 57, "line": "I'm not lit, I ignite — I shine bright" }
  ]
}
```

---

## 🔄 상태 관리

### 전역 상태 (Context API)
```typescript
interface PlayerContextType {
  currentTrack: TrackData | null;
  isPlaying: boolean;
  currentTime: number;
  volume: number;
  setCurrentTrack: (track: TrackData) => void;
  setIsPlaying: (playing: boolean) => void;
  setCurrentTime: (time: number) => void;
  setVolume: (volume: number) => void;
}

const PlayerContext = createContext<PlayerContextType | null>(null);

export const PlayerProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [currentTrack, setCurrentTrack] = useState<TrackData | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(1);
  
  return (
    <PlayerContext.Provider value={{
      currentTrack,
      isPlaying,
      currentTime,
      volume,
      setCurrentTrack,
      setIsPlaying,
      setCurrentTime,
      setVolume
    }}>
      {children}
    </PlayerContext.Provider>
  );
};
```

### 로컬 상태 (useState)
```typescript
// DetailPage 내부
const [activeTab, setActiveTab] = useState<'lyrics' | 'interpretation' | 'sync'>('lyrics');
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
```

---

## 🎨 UI/UX 가이드

### 색상 팔레트
```css
/* Tailwind CSS 색상 변수 */
:root {
  --primary: #8b5cf6; /* purple-500 */
  --primary-light: #a78bfa; /* purple-400 */
  --primary-dark: #7c3aed; /* purple-600 */
  --secondary: #64748b; /* slate-500 */
  --accent: #f1f5f9; /* slate-100 */
  --background: #ffffff;
  --text-primary: #1e293b; /* slate-800 */
  --text-secondary: #64748b; /* slate-500 */
  --border: #e2e8f0; /* slate-200 */
}
```

### 타이포그래피
```css
/* 제목 */
.heading-1 { @apply text-3xl font-bold text-gray-900; }
.heading-2 { @apply text-2xl font-semibold text-gray-900; }
.heading-3 { @apply text-xl font-medium text-gray-800; }

/* 본문 */
.body-large { @apply text-lg leading-relaxed text-gray-700; }
.body-medium { @apply text-base leading-relaxed text-gray-700; }
.body-small { @apply text-sm leading-relaxed text-gray-600; }

/* 가사 */
.lyrics-line { @apply text-base leading-relaxed; }
.lyrics-active { @apply text-purple-600 font-semibold text-lg; }
```

### 애니메이션
```css
/* 부드러운 전환 */
.transition-smooth { @apply transition-all duration-300 ease-in-out; }

/* 페이드 인 */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in { animation: fadeIn 0.5s ease-out; }

/* 하이라이트 효과 */
@keyframes highlight {
  0% { background-color: transparent; }
  50% { background-color: rgba(139, 92, 246, 0.1); }
  100% { background-color: transparent; }
}

.highlight { animation: highlight 2s ease-in-out; }
```

### 글래스모피즘 효과
```css
.glass-card {
  @apply bg-white/80 backdrop-blur-md border border-white/20 shadow-xl;
}

.glass-button {
  @apply bg-white/60 backdrop-blur-sm border border-white/30 
         hover:bg-white/80 transition-all duration-200;
}
```

---

## ⚡ 성능 최적화

### 1. 이미지 최적화
```typescript
// Next.js Image 컴포넌트 사용 (선택사항)
import Image from 'next/image';

const OptimizedCover: React.FC<{ src: string; alt: string }> = ({ src, alt }) => (
  <Image
    src={src}
    alt={alt}
    width={256}
    height={256}
    className="rounded-xl shadow-xl object-cover"
    priority
  />
);
```

### 2. 오디오 프리로딩
```typescript
const useAudioPreload = (audioUrl: string) => {
  useEffect(() => {
    const audio = new Audio(audioUrl);
    audio.preload = 'metadata';
  }, [audioUrl]);
};
```

### 3. 가상화 (긴 가사 목록)
```typescript
import { FixedSizeList as List } from 'react-window';

const VirtualizedLyrics: React.FC<{ lyrics: string[] }> = ({ lyrics }) => (
  <List
    height={400}
    itemCount={lyrics.length}
    itemSize={60}
    itemData={lyrics}
  >
    {({ index, style, data }) => (
      <div style={style} className="px-4 py-2">
        {data[index]}
      </div>
    )}
  </List>
);
```

### 4. 메모이제이션
```typescript
const MemoizedSyncContent = React.memo<SyncContentProps>(({ sync, currentTime }) => {
  // 컴포넌트 로직
});

const useMemoizedCurrentLine = (sync: SyncLine[], currentTime: number) => {
  return useMemo(() => {
    return sync.findIndex((line, index) => {
      const nextLine = sync[index + 1];
      return currentTime >= line.time && (!nextLine || currentTime < nextLine.time);
    });
  }, [sync, currentTime]);
};
```

---

## ♿ 접근성

### 1. 키보드 네비게이션
```typescript
const KeyboardNavigation: React.FC = () => {
  const handleKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case ' ':
        e.preventDefault();
        handlePlayPause();
        break;
      case 'ArrowLeft':
        handleSeek(currentTime - 10);
        break;
      case 'ArrowRight':
        handleSeek(currentTime + 10);
        break;
    }
  };
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);
};
```

### 2. 스크린 리더 지원
```typescript
const AccessiblePlayer: React.FC = () => (
  <div role="application" aria-label="음악 플레이어">
    <button
      aria-label={isPlaying ? '일시정지' : '재생'}
      onClick={handlePlayPause}
    >
      {isPlaying ? <PauseIcon /> : <PlayIcon />}
    </button>
    
    <div role="slider" aria-label="재생 위치" aria-valuenow={currentTime}>
      <Slider value={currentTime} onChange={handleSeek} />
    </div>
  </div>
);
```

### 3. 고대비 모드 지원
```css
@media (prefers-contrast: high) {
  .glass-card {
    @apply bg-white border-2 border-gray-900;
  }
  
  .lyrics-active {
    @apply text-black bg-yellow-200;
  }
}
```

---

## 🧪 테스트 전략

### 1. 단위 테스트 (Jest + React Testing Library)
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { DetailPage } from './DetailPage';

describe('DetailPage', () => {
  test('renders track information correctly', () => {
    render(<DetailPage trackId="13" />);
    
    expect(screen.getByText('Shine Bright')).toBeInTheDocument();
    expect(screen.getByText('문유')).toBeInTheDocument();
  });
  
  test('switches tabs correctly', () => {
    render(<DetailPage trackId="13" />);
    
    const interpretationTab = screen.getByText('해석');
    fireEvent.click(interpretationTab);
    
    expect(screen.getByText(/이 곡은 외부 조명 없이도/)).toBeInTheDocument();
  });
});
```

### 2. 통합 테스트
```typescript
describe('Audio Sync', () => {
  test('highlights correct lyric line based on current time', () => {
    render(<SyncContent sync={mockSync} currentTime={15} />);
    
    expect(screen.getByText('빛보다 진한 흔적')).toHaveClass('lyrics-active');
  });
});
```

### 3. E2E 테스트 (Playwright)
```typescript
import { test, expect } from '@playwright/test';

test('complete user journey', async ({ page }) => {
  await page.goto('/track/13');
  
  // 탭 전환 테스트
  await page.click('text=싱크');
  await expect(page.locator('.lyrics-active')).toBeVisible();
  
  // 재생 테스트
  await page.click('[aria-label="재생"]');
  await expect(page.locator('[aria-label="일시정지"]')).toBeVisible();
});
```

---

## 🚀 배포 체크리스트

### 빌드 최적화
- [ ] Vite 빌드 최적화 설정
- [ ] 이미지 압축 및 최적화
- [ ] 번들 크기 분석 및 최적화
- [ ] PWA 매니페스트 설정

### 성능 체크
- [ ] Lighthouse 성능 점수 90+ 확인
- [ ] Core Web Vitals 최적화
- [ ] 모바일 성능 테스트
- [ ] 오프라인 지원 확인

### 접근성 체크
- [ ] WCAG 2.1 AA 준수 확인
- [ ] 키보드 네비게이션 테스트
- [ ] 스크린 리더 호환성 확인
- [ ] 색상 대비 검증

### 브라우저 호환성
- [ ] Chrome/Edge 최신 버전
- [ ] Safari 최신 버전
- [ ] Firefox 최신 버전
- [ ] 모바일 브라우저 (iOS Safari, Chrome Mobile)

---

## 📱 PWA 설정

### manifest.json
```json
{
  "name": "Moonwave 오안나 음악 플레이어",
  "short_name": "오안나",
  "description": "평범함에서 특별함으로 - 오안나의 음악 여정",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#8b5cf6",
  "icons": [
    {
      "src": "/moonwave_log.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/moonwave_log.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Service Worker
```typescript
// sw.js
const CACHE_NAME = 'moonwave-player-v1';
const urlsToCache = [
  '/',
  '/music/shine-bright.mp3',
  '/covers/shine-bright.jpg',
  '/static/js/bundle.js',
  '/static/css/main.css'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

---

## 🎵 오디오 처리 최적화

### 오디오 컨텍스트 활용
```typescript
const useAudioContext = () => {
  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);
  
  useEffect(() => {
    const context = new (window.AudioContext || window.webkitAudioContext)();
    setAudioContext(context);
    
    return () => {
      context.close();
    };
  }, []);
  
  return audioContext;
};
```

### 오디오 시각화 (선택사항)
```typescript
const AudioVisualizer: React.FC<{ audioElement: HTMLAudioElement }> = ({ audioElement }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const audioContext = useAudioContext();
  
  useEffect(() => {
    if (!audioContext || !audioElement) return;
    
    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaElementSource(audioElement);
    
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    
    // 시각화 로직
    const draw = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      
      analyser.getByteFrequencyData(dataArray);
      
      // 캔버스에 그리기
      ctx?.clearRect(0, 0, canvas.width, canvas.height);
      // ... 시각화 로직
      
      requestAnimationFrame(draw);
    };
    
    draw();
  }, [audioContext, audioElement]);
  
  return <canvas ref={canvasRef} className="w-full h-20" />;
};
```

---

## 🔧 개발 환경 설정

### package.json 의존성
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.0",
    "@catalyst-ui/react": "^1.0.0",
    "tailwindcss": "^3.3.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^4.0.0",
    "typescript": "^5.0.0",
    "@testing-library/react": "^13.0.0",
    "@testing-library/jest-dom": "^5.16.0",
    "jest": "^29.0.0"
  }
}
```

### Vite 설정
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@catalyst-ui/react']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
});
```

---

## 📚 추가 리소스

### 참고 문서
- [화면정의서](./화면정의서) - 전체 화면 구조 및 요구사항
- [PRD](./PRD) - 프로젝트 요구사항 문서
- [Profile](./Profile) - 오안나 프로필 정보
- [디자인가이드](./디자인가이드) - Moonwave 브랜드 가이드라인

### 외부 리소스
- [React 공식 문서](https://react.dev/)
- [Catalyst UI 문서](https://catalyst-ui.com/)
- [Tailwind CSS 문서](https://tailwindcss.com/)
- [Web Audio API 문서](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)

---

*이 문서는 Moonwave 오안나 음악 플레이어의 상세 뷰페이지 개발에 필요한 모든 기술적, 디자인적, 콘텐츠적 요소를 종합적으로 정리한 완전한 개발 가이드입니다. Shine Bright 곡의 철학과 오안나의 스토리를 기술적으로 구현하는 데 필요한 모든 정보를 포함하고 있습니다.*